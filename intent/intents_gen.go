package intent

// Code generated - This file has been automatically generated by internal/generate/events/main.go - DO NOT EDIT.
// Warning: This file is overwritten at "go generate", instead adapt internal/constants/events.go and run go generate

import (
	"github.com/andersfylling/discordgateway/event"
	"github.com/andersfylling/discordgateway/internal/constants"
)

type Type constants.Intent

func (i Type) Events() []event.Type {
	return Events(i)
}

const (
	DirectMessageReactions Type = 13
	DirectMessageTyping    Type = 14
	DirectMessages         Type = 12
	GuildBans              Type = 2
	GuildEmojis            Type = 3
	GuildIntegrations      Type = 4
	GuildInvites           Type = 6
	GuildMembers           Type = 1
	GuildMessageReactions  Type = 10
	GuildMessageTyping     Type = 11
	GuildMessages          Type = 9
	GuildPresences         Type = 8
	GuildVoiceStates       Type = 7
	GuildWebhooks          Type = 5
	Guilds                 Type = 0
)

var intentsToEventsMap = map[Type][]event.Type{
	DirectMessageReactions: []event.Type{event.MessageReactionCreate, event.MessageReactionDelete, event.MessageReactionDeleteAll, event.MessageReactionDeleteEmoji},
	DirectMessageTyping:    []event.Type{event.TypingStart},
	DirectMessages:         []event.Type{event.ChannelCreate, event.MessageCreate, event.MessageUpdate, event.MessageDelete, event.ChannelPinsUpdate},
	GuildBans:              []event.Type{event.GuildBanCreate, event.GuildBanDelete},
	GuildEmojis:            []event.Type{event.GuildEmojisUpdate},
	GuildIntegrations:      []event.Type{event.GuildIntegrationsUpdate, event.IntegrationCreate, event.IntegrationUpdate, event.IntegrationDelete},
	GuildInvites:           []event.Type{event.InviteCreate, event.InviteDelete},
	GuildMembers:           []event.Type{event.GuildMemberCreate, event.GuildMemberUpdate, event.GuildMemberDelete, event.ThreadMembersUpdate},
	GuildMessageReactions:  []event.Type{event.MessageReactionCreate, event.MessageReactionDelete, event.MessageReactionDeleteAll, event.MessageReactionDeleteEmoji},
	GuildMessageTyping:     []event.Type{event.TypingStart},
	GuildMessages:          []event.Type{event.MessageCreate, event.MessageUpdate, event.MessageDelete, event.MessageDeleteBulk},
	GuildPresences:         []event.Type{event.PresenceUpdate},
	GuildVoiceStates:       []event.Type{event.VoiceStateUpdate},
	GuildWebhooks:          []event.Type{event.WebhooksUpdate},
	Guilds:                 []event.Type{event.GuildCreate, event.GuildUpdate, event.GuildDelete, event.GuildRoleCreate, event.GuildRoleUpdate, event.GuildRoleDelete, event.ChannelCreate, event.ChannelUpdate, event.ChannelDelete, event.ChannelPinsUpdate, event.ThreadCreate, event.ThreadUpdate, event.ThreadDelete, event.ThreadListSync, event.ThreadMemberUpdate, event.ThreadMembersUpdate},
}

var emptyStruct struct{}
var dmIntents = map[Type]struct{}{
	DirectMessageReactions: emptyStruct,
	DirectMessageTyping:    emptyStruct,
	DirectMessages:         emptyStruct,
}

func Events(intent Type) []event.Type {
	if events, ok := intentsToEventsMap[intent]; ok {
		cpy := make([]event.Type, len(events))
		copy(cpy, events)
		return cpy
	}
	return nil
}

func All() []Type {
	return []Type{
		DirectMessageReactions, DirectMessageTyping, DirectMessages, GuildBans, GuildEmojis, GuildIntegrations, GuildInvites, GuildMembers, GuildMessageReactions, GuildMessageTyping, GuildMessages, GuildPresences, GuildVoiceStates, GuildWebhooks, Guilds,
	}
}

func Merge(intents ...Type) Type {
	var merged Type
	for i := range intents {
		merged |= intents[i]
	}
	return merged
}

func DMEventsToIntents(src []event.Type) []Type {
	return eventsToIntents(src, true)
}

func GuildEventsToIntents(src []event.Type) []Type {
	return eventsToIntents(src, false)
}

func eventsToIntents(src []event.Type, dm bool) (intents []Type) {
	contains := func(haystack []event.Type, needle event.Type) bool {
		for i := range haystack {
			if haystack[i] == needle {
				return true
			}
		}
		return false
	}

	hits := make(map[Type]struct{})
	for i := range src {
		for intent, events := range intentsToEventsMap {
			if _, isDM := dmIntents[intent]; (!dm && isDM) || (dm && !isDM) {
				continue
			}
			if contains(events, src[i]) {
				hits[intent] = emptyStruct
			}
		}
	}

	for intent := range hits {
		intents = append(intents, intent)
	}
	return intents
}
